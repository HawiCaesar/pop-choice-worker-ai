# Migration Plan: Supabase to Convex

## Overview

This document outlines the migration strategy for moving from Supabase to Convex in the `pop-choice-worker` Cloudflare Worker project. The worker currently uses Supabase for vector similarity search to find movie recommendations.

---

## Current Architecture

### Supabase Usage

| Component | Current Implementation |
|-----------|----------------------|
| **Client Library** | `@supabase/supabase-js` |
| **Authentication** | `SUPABASE_URL` + `SUPABASE_API_KEY` |
| **Vector Search** | RPC function `match_popchoice_unstructured` |
| **Data Returned** | `{ id: number, content: string }` |

### Current Flow

```
1. Receive user preferences → 
2. Generate embedding (OpenAI) → 
3. Vector search (Supabase RPC) → 
4. LLM recommendation (OpenAI) → 
5. Return results
```

### Supabase RPC Parameters

```typescript
supabase.rpc('match_popchoice_unstructured', {
  query_embedding: embedding,    // float[] - 1536 dimensions (text-embedding-3-small)
  match_threshold: 0.2,          // similarity threshold
  match_count: 6,                // number of results
});
```

---

## Migration Steps

### Phase 1: Convex Project Setup

#### 1.1 Install Convex Dependencies

```bash
npm install convex
```

#### 1.2 Initialize Convex Project

```bash
npx convex dev
```

This will:
- Create a `convex/` directory
- Generate `convex/_generated/` files
- Create initial configuration files

#### 1.3 Project Structure (New Files)

```
pop-choice-worker/
├── convex/
│   ├── _generated/          # Auto-generated by Convex
│   ├── schema.ts            # Database schema
│   └── movies.ts            # Movie queries/mutations/actions
├── src/
│   └── index.ts             # Updated worker code
└── ...
```

---

### Phase 2: Define Convex Schema

#### 2.1 Create Schema (`convex/schema.ts`)

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  movies: defineTable({
    content: v.string(),
    embedding: v.array(v.float64()),
  }).vectorIndex("by_embedding", {
    vectorField: "embedding",
    dimensions: 1536,  // text-embedding-3-small dimension
    filterFields: [],  // Add filter fields if needed
  }),
});
```

---

### Phase 3: Create Convex Functions

#### 3.1 Vector Search Action (`convex/movies.ts`)

```typescript
import { action, internalQuery } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";

export const searchMovies = action({
  args: {
    embedding: v.array(v.float64()),
    matchThreshold: v.number(),
    matchCount: v.number(),
  },
  handler: async (ctx, args) => {
    const results = await ctx.vectorSearch("movies", "by_embedding", {
      vector: args.embedding,
      limit: args.matchCount,
    });

    // Filter by threshold (Convex returns scores, not distances)
    const filteredResults = results.filter(
      (result) => result._score >= args.matchThreshold
    );

    // Fetch full documents
    const movies = await Promise.all(
      filteredResults.map(async (result) => {
        const doc = await ctx.runQuery(internal.movies.getMovie, {
          id: result._id,
        });
        return {
          id: result._id,
          content: doc?.content ?? "",
          score: result._score,
        };
      })
    );

    return movies;
  },
});

// Internal query to fetch movie by ID
export const getMovie = internalQuery({
  args: { id: v.id("movies") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.id);
  },
});
```

> **Note:** No HTTP router needed! We'll use Convex's built-in `ConvexHttpClient` to call this action directly from the Cloudflare Worker.

---

### Phase 4: Data Migration

#### 4.1 Prepare Data Source

You have a `movies.txt` file available. Depending on its format, parsing may vary.

**If already JSON or structured:**

```typescript
// scripts/import-to-convex.ts
import { ConvexHttpClient } from "convex/browser";
import { api } from "../convex/_generated/api";
import fs from "fs";

const client = new ConvexHttpClient(process.env.CONVEX_URL!);

async function importData() {
  // Adjust parsing based on your movies.txt format
  const rawData = fs.readFileSync("movies.txt", "utf-8");
  const movies = JSON.parse(rawData); // or custom parsing

  for (const movie of movies) {
    await client.mutation(api.movies.importMovie, {
      content: movie.content,
      embedding: movie.embedding,
    });
    console.log(`Imported movie: ${movie.title || movie.id}`);
  }
  console.log("Migration complete!");
}

importData();
```

#### 4.2 Import Mutation (`convex/movies.ts`)

Add this mutation to your `convex/movies.ts` file:

```typescript
import { mutation } from "./_generated/server";

export const importMovie = mutation({
  args: {
    content: v.string(),
    embedding: v.array(v.float64()),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("movies", {
      content: args.content,
      embedding: args.embedding,
    });
  },
});
```

#### 4.3 If movies.txt Needs Embeddings Generated

If your `movies.txt` only contains movie content (no embeddings), you'll need to generate embeddings first:

```typescript
// scripts/generate-embeddings-and-import.ts
import { ConvexHttpClient } from "convex/browser";
import { api } from "../convex/_generated/api";
import OpenAI from "openai";
import fs from "fs";

const client = new ConvexHttpClient(process.env.CONVEX_URL!);
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

async function importWithEmbeddings() {
  const rawData = fs.readFileSync("movies.txt", "utf-8");
  const movies = parseMovies(rawData); // Implement based on your format

  for (const movie of movies) {
    // Generate embedding
    const embeddingResponse = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: movie.content,
      encoding_format: "float",
    });
    const embedding = embeddingResponse.data[0].embedding;

    // Import to Convex
    await client.mutation(api.movies.importMovie, {
      content: movie.content,
      embedding: embedding,
    });

    console.log(`Imported: ${movie.title || "movie"}`);
  }

  console.log("Migration complete!");
}

function parseMovies(data: string) {
  // TODO: Implement based on your movies.txt format
  // Return array of { content: string, title?: string }
}

importWithEmbeddings();
```

---

### Phase 5: Update Cloudflare Worker

#### 5.1 Update Dependencies

```bash
npm uninstall @supabase/supabase-js
npm install convex
```

Updated `package.json`:

```json
{
  "dependencies": {
    "convex": "^1.x.x",
    "openai": "^6.7.0"
  }
}
```

#### 5.2 Update Environment Variables

**Remove:**
- `SUPABASE_URL`
- `SUPABASE_API_KEY`

**Add:**
- `CONVEX_URL` (e.g., `https://your-deployment.convex.cloud`)

#### 5.3 Update Worker Code (`src/index.ts`)

**Before (Supabase):**

```typescript
import { createClient } from '@supabase/supabase-js';

// Inside fetch handler:
const supabase = createClient(env.SUPABASE_URL, env.SUPABASE_API_KEY);

const { error, data: matchedVectorStoreResults } = await supabase.rpc(
  'match_popchoice_unstructured',
  {
    query_embedding: embedding,
    match_threshold: 0.2,
    match_count: 6,
  }
);

if (error) {
  console.error('Error matching documents in supabase:', error);
  return new Response(JSON.stringify({ error: '...' }), { status: 500 });
}
matchedResults = matchedVectorStoreResults;
```

**After (Convex with ConvexHttpClient):**

```typescript
import { ConvexHttpClient } from "convex/browser";
import { api } from "../convex/_generated/api";

// Inside fetch handler:
const convex = new ConvexHttpClient(env.CONVEX_URL);

try {
  const matchedVectorStoreResults = await convex.action(api.movies.searchMovies, {
    embedding: embedding,
    matchThreshold: 0.2,
    matchCount: 6,
  });
  matchedResults = matchedVectorStoreResults;
} catch (error: any) {
  console.error('Error matching documents in Convex:', error);
  return new Response(JSON.stringify({ error: 'Error matching documents in Convex', details: error.message }), {
    status: 500,
    headers: { ...allowedHeaders },
  });
}
```

#### 5.4 Full Updated Worker Structure

```typescript
import OpenAI from 'openai';
import { ConvexHttpClient } from "convex/browser";
import { api } from "../convex/_generated/api";

// ... corsHeaders, getAllowedOrigins, isOriginAllowed functions remain the same ...

export default {
  async fetch(request, env, ctx): Promise<Response> {
    // ... CORS and method handling remains the same ...

    const openai = new OpenAI({
      apiKey: env.OPENAI_API_KEY,
      baseURL: env.CLOUDFLARE_GATEWAY_URL,
    });

    const convex = new ConvexHttpClient(env.CONVEX_URL);

    // ... request parsing and embedding generation remains the same ...

    // Vector search with Convex (replaces Supabase RPC)
    try {
      matchedResults = await convex.action(api.movies.searchMovies, {
        embedding: embedding,
        matchThreshold: 0.2,
        matchCount: 6,
      });
    } catch (error: any) {
      console.error('Error matching documents in Convex:', error);
      return new Response(JSON.stringify({ 
        error: 'Error matching documents in Convex', 
        details: error.message 
      }), {
        status: 500,
        headers: { ...allowedHeaders },
      });
    }

    // ... rest of the code (LLM call, response) remains the same ...
  },
} satisfies ExportedHandler<Env>;
```

---

### Phase 6: Testing & Validation

#### 6.1 Unit Tests

Update `test/index.spec.ts` to mock Convex:

```typescript
import { vi } from 'vitest';

// Mock ConvexHttpClient
vi.mock('convex/browser', () => ({
  ConvexHttpClient: vi.fn().mockImplementation(() => ({
    action: vi.fn().mockResolvedValue([
      { id: 'abc123', content: 'Movie content...', score: 0.85 }
    ]),
  })),
}));
```

#### 6.2 Integration Testing Checklist

- [ ] Vector search returns expected results
- [ ] Embedding dimensions match (1536 for text-embedding-3-small)
- [ ] Score/threshold filtering works correctly
- [ ] Error handling for Convex failures
- [ ] CORS headers still applied correctly
- [ ] Response format unchanged for frontend

#### 6.3 Performance Comparison

| Metric | Supabase | Convex (Expected) |
|--------|----------|-------------------|
| Cold start | ~200ms | ~100ms |
| Vector search latency | ~150ms | ~50-100ms |
| Data consistency | Eventual | Real-time |

---

### Phase 7: Deployment

#### 7.1 Convex Deployment

```bash
# Deploy Convex functions
npx convex deploy
```

#### 7.2 Update Cloudflare Secrets

```bash
# Remove old secrets
wrangler secret delete SUPABASE_URL
wrangler secret delete SUPABASE_API_KEY

# Add new secrets
wrangler secret put CONVEX_URL
```

#### 7.3 Deploy Worker

```bash
npm run deploy
```

---

## Environment Variables Summary

### Before (Supabase)

| Variable | Description |
|----------|-------------|
| `SUPABASE_URL` | Supabase project URL |
| `SUPABASE_API_KEY` | Supabase anon/service key |
| `OPENAI_API_KEY` | OpenAI API key |
| `CLOUDFLARE_GATEWAY_URL` | Cloudflare AI Gateway URL |
| `ALLOWED_ORIGINS` | CORS allowed origins |

### After (Convex)

| Variable | Description |
|----------|-------------|
| `CONVEX_URL` | Convex deployment URL |
| `OPENAI_API_KEY` | OpenAI API key (unchanged) |
| `CLOUDFLARE_GATEWAY_URL` | Cloudflare AI Gateway URL (unchanged) |
| `ALLOWED_ORIGINS` | CORS allowed origins (unchanged) |

---

## Rollback Plan

If issues arise, rollback by:

1. Revert `src/index.ts` to Supabase implementation
2. Re-add Supabase dependencies: `npm install @supabase/supabase-js`
3. Restore Supabase environment variables
4. Redeploy worker

Keep Supabase data intact for at least 30 days post-migration.

---

## Benefits of Convex

1. **Built-in Vector Search** - Native support without custom RPC functions
2. **Real-time Subscriptions** - If you add real-time features later
3. **Type Safety** - End-to-end TypeScript types with auto-generated API
4. **Automatic Caching** - Improved performance
5. **Simpler Schema** - No SQL migrations needed
6. **Better DX** - Hot reloading during development
7. **ConvexHttpClient** - Simple, type-safe way to call functions from external services

---

## Timeline Estimate

| Phase | Duration | Notes |
|-------|----------|-------|
| Phase 1: Setup | 30 min | Initial Convex setup |
| Phase 2: Schema | 15 min | Define data schema |
| Phase 3: Functions | 1 hour | Write Convex action (no HTTP router needed) |
| Phase 4: Migration | 1-2 hours | Depends on movies.txt format |
| Phase 5: Worker Update | 1 hour | Update worker code |
| Phase 6: Testing | 2-3 hours | Thorough testing |
| Phase 7: Deployment | 30 min | Deploy and verify |

**Total Estimated Time: 6-8 hours**

---

## Additional Resources

- [Convex Documentation](https://docs.convex.dev/)
- [Convex Vector Search](https://docs.convex.dev/vector-search)
- [ConvexHttpClient Reference](https://docs.convex.dev/api/classes/browser.ConvexHttpClient)
- [Convex Actions](https://docs.convex.dev/functions/actions)
- [Data Import/Export](https://docs.convex.dev/database/import-export)

---

## Questions to Resolve Before Migration

1. ~~**Data Volume**: How many movie records exist in Supabase?~~ → Using movies.txt file
2. **movies.txt Format**: What is the format of the file? (JSON, CSV, line-delimited?)
3. **Embeddings**: Does movies.txt include pre-computed embeddings or just content?
4. **Downtime Tolerance**: Is zero-downtime migration required?
5. **Convex Plan**: Free tier or Pro? (affects rate limits)
